---
title: "Projet_Final_Tri"
author: "NJ"
date: "2024-11-23"
output: html_document
---

---
title: "Projet_Final"
author: "NJ"
date: "2024-10-26"
output: html_document
---
```{r}
# Lien direct du fichier Google Drive
url <- "https://drive.google.com/uc?id=1KoT90a-sNNwV2X4KSQQqLmmDcYGNg9v-"

# Lire les données depuis l'URL
data <- read.csv(url)

# Afficher les premières lignes des données
head(data)
```



```{r}
library(readr)
indiceDesPrix_WE <- read_csv("https://drive.google.com/file/d/1KoT90a-sNNwV2X4KSQQqLmmDcYGNg9v-")
indiceDesPrix_WE[[1]] <- as.Date(indiceDesPrix_WE[[1]], format = "%Y-%m-%d")
indiceDesPrix_WE[[2]] <- as.numeric(gsub(",", ".", indiceDesPrix_WE[[2]]))
IDP_WE <- ts(indiceDesPrix_WE[[2]], start = c(1967, 1), frequency = 4)
IDP_WE_subset <- window(IDP_WE, start = c(1967, 1), end = c(2023, 4))
plot(IDP_WE_subset, main = "Indice des Prix (1967-2023)", ylab = "Indice", xlab = "Année")

```




```{r}
IDP_df<-as.data.frame(IDP_WE)
nbre_na<-sum(is.na(IDP_df))
```



```{r}
library(readr)
setwd("C:/Users/33670/Documents/M2 semestre 9/Time series/Projet_Final")
gaz <- read_csv("gaz_TRI.csv")
gaz[[1]] <- as.Date(gaz[[1]], format = "%Y-%m-%d")
gaz[[2]] <- as.numeric(gsub(",", ".", gaz[[2]]))  # Remplace ',' par '.' si nécessaire
gaz_ts <- ts(gaz[[2]], start = c(1967, 1), frequency = 4)
gaz_subset <- window(gaz_ts, start = c(1967, 1), end = c(2023, 4))
plot(
  gaz_subset, 
  main = "Évolution des prix du gaz (1967-2023)", 
  ylab = "Indice", 
  xlab = "Année"
)
length(gaz_subset)


#539

```

```{r}
gaz_df<-as.data.frame(gaz)
nbre_na<-sum(is.na(gaz_df))
```

```{r}
library(readr)
setwd("C:/Users/33670/Documents/M2 semestre 9/Time series/Projet_Final")
essence <- read_csv("essence_TRI.csv")
essence[[1]] <- as.Date(essence[[1]], format = "%Y-%m-%d")
essence[[2]] <- as.numeric(gsub(",", ".", essence[[2]]))  # Remplace ',' par '.' si besoin
essence_ts <- ts(essence[[2]], start = c(1967, 1), frequency = 4)
essence_subset <- window(essence_ts, start = c(1967, 1), end = c(2023, 4))
plot(
  essence_subset,
  main = "Évolution des prix de l'essence (1967-2023)",
  ylab = "Indice",
  xlab = "Année"
)
length(essence_subset)

```

```{r}
essence_df<-as.data.frame(essence)
nbre_na<-sum(is.na(essence_df))
```


```{r}
library(readr)
electricite <- read_csv("electricite_IPC.csv")

electricite <- ts(electricite[, 2], start = c(1967, 1), frequency = 4)
electricite_subset <- window(electricite, start = c(1967, 1), end = c(2023, 4))
plot(electricite_subset, main = "electricite (1979-2023)", ylab = "Indice", xlab = "Année")

length(electricite_subset)
#539
```


```{r}
library(readr)
setwd("C:/Users/33670/Documents/M2 semestre 9/Time series/Projet_Final")
Taux_Change <- read_csv("Taux_Change.csv")
Taux_Change[[1]] <- as.Date(Taux_Change[[1]], format = "%Y-%m-%d")
Taux_Change[[2]] <- as.numeric(gsub(",", ".", Taux_Change[[2]]))  # Remplace ',' par '.' si besoin
Taux_Change_ts <- ts(Taux_Change[[2]], start = c(1967, 1), frequency = 4)
Taux_Change_subset <- window(Taux_Change_ts, start = c(1967, 1), end = c(2023, 4))
plot(
  Taux_Change_subset,
  main = "Évolution Taux_Change (1967-2023)",
  ylab = "Indice",
  xlab = "Année"
)
length(Taux_Change_subset)
```

```{r}
indiceDesPrix_WE_c <- read_csv("indiceDesPrix_WE.csv")

electricite_c <- read_csv("electricite_IPC.csv")
essence_c <- read_csv("essence_IPC.csv")
gaz_c <- read_csv("gaz_IPC.csv")


# Convertir en objets ts
indiceDesPrix_WE_c <- ts(indiceDesPrix_WE_c[, 2], start = c(1979, 1), end = c(2023, 11), frequency = 12)
electricite_c <- ts(electricite_c[, 2], start = c(1979, 1), end = c(2023, 11), frequency = 12)
essence_c <- ts(essence_c[, 2], start = c(1979, 1), end = c(2023, 11), frequency = 12)
gaz_c <- ts(gaz_c[, 2], start = c(1979, 1), end = c(2023, 11), frequency = 12)

# Rassembler les séries en une série temporelle multivariée
combined_series <- cbind(  indiceDesPrix_WE_c, electricite_c, essence_c, gaz_c)
plot(combined_series)

```

```{r}
# Normaliser les séries temporelles
combined_normalized <- scale(combined_series)

# Tracer les séries normalisées
matplot(combined_normalized, type = "l", lty = 1, col = 1:6,
        main = "Comparaison des Séries Normalisées (1979-2023)", xlab = "Année", ylab = "Valeurs Normalisées")
legend("topright", legend = c( "indiceDesPrix_c", "electricite_c", "essence_c", "gaz_c"), col = 1:6, lty = 1)

```

```{r}
cor_matrix <- cor(combined_series)
print(cor_matrix)

```
# Analyses Descriptive







```{r}
par(mfrow = c(2, 2))  

plot(IDP_WE_subset, main = "Série Temporelle", ylab = "Valeurs", xlab = "Temps")    
hist(IDP_WE_subset, breaks = 20, main = "Histogramme", xlab = "Valeurs")            
boxplot(IDP_WE_subset, main = "Boxplot de la Série Temporelle", horizontal = TRUE)  
acf(IDP_WE_subset, main = "Fonction d'Autocorrélation (ACF)")  
```


```{r}
par(mfrow = c(2, 2))  

plot(electricite_subset, main = "Série Temporelle", ylab = "Valeurs", xlab = "Temps")    
hist(electricite_subset, breaks = 20, main = "Histogramme", xlab = "Valeurs")            
boxplot(electricite_subset, main = "Boxplot de la Série Temporelle", horizontal = TRUE)  
acf(electricite_subset, main = "Fonction d'Autocorrélation (ACF)")  
```

```{r}
par(mfrow = c(2, 2))  

plot(essence_subset, main = "Série Temporelle", ylab = "Valeurs", xlab = "Temps")    
hist(essence_subset, breaks = 20, main = "Histogramme", xlab = "Valeurs")            
boxplot(essence_subset, main = "Boxplot de la Série Temporelle", horizontal = TRUE)  
acf(essence_subset, main = "Fonction d'Autocorrélation (ACF)")  
```

```{r}
par(mfrow = c(2, 2))  

plot(gaz_subset, main = "Série Temporelle", ylab = "Valeurs", xlab = "Temps")    
hist(gaz_subset, breaks = 20, main = "Histogramme", xlab = "Valeurs")            
boxplot(gaz_subset, main = "Boxplot de la Série Temporelle", horizontal = TRUE)  
acf(gaz_subset, main = "Fonction d'Autocorrélation (ACF)")  
```


```{r}

kruskal.test(IDP_WE_subset ~ cycle(IDP_WE_subset))
kruskal.test(electricite_subset ~ cycle(electricite_subset))
kruskal.test(essence_subset ~ cycle(essence_subset))
kruskal.test(gaz_subset ~ cycle(gaz_subset)) 

```

```{r}
pacf(electricite_subset, main = "Fonction d'Autocorrélation Partielle (PACF)")
#electricité semble avoir de la saisonalité

```


## IDP_WE

```{r}

library(astsa)
dlog_IDP_WE<-diff(log(IDP_WE_subset))
plot(dlog_IDP_WE)
library(forecast)
ggsubseriesplot(dlog_IDP_WE)

aux1 <- acf2(dlog_IDP_WE)
library(forecast)
arorder <- 4
TTmodel <- Arima(dlog_IDP_WE,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)
library(TSA)
eacf(dlog_IDP_WE)

```



```{r}
library(tseries)
adf.test(dlog_IDP_WE)  
# On peut rejeter l'hypothése nulle, la série est stationnaire

kw_test <- kruskal.test(as.numeric(dlog_IDP_WE) ~ cycle(dlog_IDP_WE))
print(kw_test)
# On ne eut pas rejeter l'hypothèse nulle, il n'y a pas de saisonnalité
```

```{r}

ARMA11 <- Arima(log(IDP_WE_subset),order=c(2,1,0),
                 include.constant = TRUE, method="CSS-ML")
library(pander)
pander(ARMA11,style="rmarkdown")

autoplot(ARMA11)

checkresiduals(ARMA11)


```


```{r}
library(pander)
sarima_011 <- Arima(log(IDP_WE_subset),order=c(2,1,0),
seasonal = list(order=c(0,1,1)),
include.constant = TRUE, method="CSS-ML")
pander(sarima_011,style="rmarkdown")

autoplot(sarima_011)

checkresiduals(sarima_011)

```

## Taux_Change

```{r}
plot(Taux_Change_subset)
plot(log(Taux_Change_subset))
plot(diff(log(Taux_Change_subset)))
plot(diff(Taux_Change_subset))

```


```{r}

library(astsa)
dlog_Taux_Change<-diff(log(Taux_Change_subset))
plot(dlog_Taux_Change)
library(forecast)
ggsubseriesplot(dlog_Taux_Change)

aux1 <- acf2(dlog_Taux_Change)
library(forecast)
arorder <- 2
TTmodel <- Arima(dlog_Taux_Change,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)
library(TSA)
eacf(dlog_Taux_Change)

```

```{r}
library(tseries)
adf.test(dlog_Taux_Change)  

kw_test <- kruskal.test(as.numeric(dlog_Taux_Change) ~ cycle(dlog_Taux_Change))
print(kw_test)
```


## gaz



```{r}
library(astsa)
dlog_gaz<-diff(log(gaz_subset))
plot(dlog_gaz)
ggsubseriesplot(dlog_gaz)
aux <- acf2(dlog_gaz)

library(forecast)
arorder <- 3
TTmodel <- Arima(dlog_gaz,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)

eacf(dlog_gaz)


```

```{r}
library(forecast)
arorder <- 11
TTmodel <- Arima(dlog_gaz,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)

d10log_gaz <- diff(dlog_gaz, 10)
plot(d10log_gaz)

aux <- acf2(d10log_gaz)

 library(uroot)
 test.sur <- hegy.test(dlog_gaz, deterministic=c(1,0,0),
 lag.method = "fixed", maxlag = 11)
 summary(test.sur)

```


```{r}
library(tseries)
adf.test(dlog_gaz)  

kw_test <- kruskal.test(as.numeric(dlog_gaz) ~ cycle(dlog_gaz))
print(kw_test)
```




```{r}
ARMA11 <- Arima(log(gaz_subset),order=c(0,1,1),
                 include.constant = TRUE, method="CSS-ML")
pander(ARMA11,style="rmarkdown")

autoplot(ARMA11)

checkresiduals(ARMA11)

```
```{r}
library(pander)
sarima_011 <- Arima(log(gaz_subset),order=c(0,1,1),
seasonal = list(order=c(0,1,1)),
include.constant = TRUE, method="CSS-ML")
pander(sarima_011,style="rmarkdown")

```


## essence

```{r}
plot(log(essence_subset))
```


```{r}
library(astsa)
ggsubseriesplot(essence_subset)
ggsubseriesplot(log(essence_subset))
ggsubseriesplot(diff(log(essence_subset)))



dlog_essence<-diff(log(essence_subset))
plot(dlog_essence)
aux <- acf2(dlog_essence)

library(forecast)
arorder <- 2
TTmodel <- Arima(dlog_essence,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)

eacf(dlog_essence)


```

```{r}
library(tseries)
adf.test(dlog_essence)  

kw_test <- kruskal.test(as.numeric(dlog_essence) ~ cycle(dlog_essence))
print(kw_test)
```

```{r}

ARMA11 <- Arima(log(essence_subset),order=c(1,1,1),
                 include.constant = TRUE, method="CSS-ML")
pander(ARMA11,style="rmarkdown")

autoplot(ARMA11)

checkresiduals(ARMA11)

```

```{r}
d4dlog_JJ <- diff(log(essence_subset), 1)
plot(d4dlog_JJ)

aux <- acf2(d4dlog_JJ)

library(uroot)
test.sur <- hegy.test(log(essence_subset), deterministic=c(1,1,0),
lag.method = "fixed", maxlag = 1)
summary(test.sur)
```


```{r}
library(pander)
sarima_011 <- Arima(log(essence_subset),order=c(1,1,1),
seasonal = list(order=c(0,1,1)),
include.constant = TRUE, method="CSS-ML")
pander(sarima_011,style="rmarkdown")

autoplot(sarima_011)

checkresiduals(sarima_011)
```

```{r}

ARMA11 <- Arima(log(essence_subset),order=c(1,1,1),
                 include.constant = TRUE, method="CSS-ML")
pander(ARMA11,style="rmarkdown")


```





## electricité

```{r}

dlog_electricite<-diff(log(electricite_subset))
plot(dlog_electricite)
ggsubseriesplot(dlog_electricite)
aux <- acf2(dlog_electricite)

library(forecast)
arorder <- 2
TTmodel <- Arima(dlog_electricite,
order=c(arorder,0,0),method="CSS")
autoplot(TTmodel)




```

```{r}
library(tseries)
adf.test(dlog_electricite)  # "ts_data_diff12" est votre série différenciée
# On peut pas rejeter l'hypothése nulle, la série n'est pas stationnaire
```





```{r}
arima <- Arima(electricite_subset,order=c(0,1,1),
lambda=0,
include.constant = TRUE, method="CSS-ML")
library(pander)
pander(arima,style="rmarkdown")
```

## Var





```{r}

# Sélection du nombre de lags optimal pour 6 séries
library(vars)
lag_selection <- VARselect(d12log_electricite, lag.max = 18, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

# Afficher les critères de sélection
print(lag_selection$selection)
```

```{r}

# Sélection du nombre de lags optimal pour 6 séries
lag_selection <- VARselect(d12log_essence, lag.max = 18, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

# Afficher les critères de sélection
print(lag_selection$selection)
```

```{r}

# Sélection du nombre de lags optimal pour 6 séries
lag_selection <- VARselect(d11log_gaz, lag.max = 18, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

# Afficher les critères de sélection
print(lag_selection$selection)
```


```{r}
# Créer le data.frame en excluant les lignes souhaitées
ts_data <- data.frame(
  #d12log_IDP,
  #PIB_subset[-(1:12), ],         # Exclure les 12 premières lignes de PIB_subset
  dlog_IDP_WE, #529
  #dlog_electricite, #526
  dlog_essence, #527
  dlog_gaz #527            # Exclure la première ligne de d11log_gaz
)

# Installer et charger dplyr si ce n'est pas déjà fait
library(dplyr)
library(vars)



lag_selection <- VARselect(ts_data, lag.max = 24, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

print(lag_selection$selection)
```

```{r}

# Estimer le modèle VAR avec le lag optimal
var_model <- VAR(ts_data, p = 2, type = "const")

# Résumé du modèle
summary(var_model)

# Tester l'autocorrélation des résidus
serial_test <- serial.test(var_model, lags.pt = 16, type = "PT.asymptotic")
print(serial_test)

# Test de normalité des résidus
normality_test <- normality.test(var_model)
print(normality_test)

# Test d'hétéroscédasticité des résidus
arch_test <- arch.test(var_model, lags.multi = 5)
print(arch_test)

# Analyser la causalité de Granger entre les séries
# Pour chaque série, tester si elle cause les autres
for (i in colnames(ts_data)) {
  print(causality(var_model, cause = i))
}

```

```{r}

# Calculer les fonctions de réponse impulsionnelle (IRF) pour voir comment chaque série réagit aux chocs des autres
irf_result <- irf(var_model, n.ahead = 20, boot = TRUE)
plot(irf_result)

# Décomposition de la variance pour voir la contribution de chaque variable aux autres sur un horizon de 10 périodes
#fevd_result <- fevd(var_model, n.ahead = 10)
#plot(fevd_result)
```


```{r}
# Matrice de corrélation
cor_matrix <- cor(ts_data)
print(cor_matrix)

# Visualiser la matrice de corrélation
library(corrplot)
corrplot(cor_matrix, method = "circle")

```


Si l'objectif est la prédiction à court terme ou la modélisation détaillée des interactions entre les variables, choisis AIC ou FPE.
Si l'objectif est l'interprétabilité et la robustesse du modèle (par exemple, pour comprendre des relations structurelles sans trop surcharger le modèle), choisis BIC.
Si tu souhaites un compromis entre complexité et précision, opte pour HQ.

```{r}
# Créer le data.frame en excluant les lignes souhaitées
ts_data <- data.frame(
  #d12log_IDP,
  #PIB_subset[-(1:12), ],         # Exclure les 12 premières lignes de PIB_subset
  dlog_Taux_Change, #529
  #dlog_electricite, #526
  dlog_essence, #527
  dlog_gaz #527            # Exclure la première ligne de d11log_gaz
)

# Installer et charger dplyr si ce n'est pas déjà fait
library(dplyr)
library(vars)



lag_selection <- VARselect(ts_data, lag.max = 24, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

print(lag_selection$selection)
```

```{r}

# Estimer le modèle VAR avec le lag optimal
var_model <- VAR(ts_data, p = 2, type = "const")

# Résumé du modèle
summary(var_model)

# Tester l'autocorrélation des résidus
serial_test <- serial.test(var_model, lags.pt = 16, type = "PT.asymptotic")
print(serial_test)

# Test de normalité des résidus
normality_test <- normality.test(var_model)
print(normality_test)

# Test d'hétéroscédasticité des résidus
arch_test <- arch.test(var_model, lags.multi = 5)
print(arch_test)

# Analyser la causalité de Granger entre les séries
# Pour chaque série, tester si elle cause les autres
for (i in colnames(ts_data)) {
  print(causality(var_model, cause = i))
}

```




```{r}
# Créer le data.frame en excluant les lignes souhaitées
ts_gaz <- data.frame(
  dlog_essence,
  dlog_gaz             # Exclure la première ligne de d11log_gaz
)


# Installer et charger dplyr si ce n'est pas déjà fait
library(dplyr)
library(vars)


lag_selection <- VARselect(ts_gaz, lag.max = 12, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

print(lag_selection$selection)
```

```{r}

# Estimer le modèle VAR avec le lag optimal
var_model <- VAR(ts_gaz, p = 2, type = "const")

# Résumé du modèle
summary(var_model)

# Tester l'autocorrélation des résidus
serial_test <- serial.test(var_model, lags.pt = 16, type = "PT.asymptotic")
print(serial_test)

# Test de normalité des résidus
normality_test <- normality.test(var_model)
print(normality_test)

# Test d'hétéroscédasticité des résidus
arch_test <- arch.test(var_model, lags.multi = 5)
print(arch_test)

# Analyser la causalité de Granger entre les séries
# Pour chaque série, tester si elle cause les autres
for (i in colnames(ts_gaz)) {
  print(causality(var_model, cause = i))
}

```

```{r}
# Créer le data.frame en excluant les lignes souhaitées
ts_essence <- data.frame(
  dlog_IDP_WE,
  dlog_essence             # Exclure la première ligne de d11log_gaz
)


# Installer et charger dplyr si ce n'est pas déjà fait
library(dplyr)
library(vars)


lag_selection <- VARselect(ts_essence, lag.max = 12, type = "const") # Ajuster lag.max si nécessaire
optimal_lag <- lag_selection$selection["AIC(n)"] # Ou utiliser BIC, HQ selon tes besoins

print(lag_selection$selection)
```

```{r}

# Estimer le modèle VAR avec le lag optimal
var_model <- VAR(ts_essence, p = 3, type = "const")

# Résumé du modèle
summary(var_model)

# Tester l'autocorrélation des résidus
serial_test <- serial.test(var_model, lags.pt = 16, type = "PT.asymptotic")
print(serial_test)

# Test de normalité des résidus
normality_test <- normality.test(var_model)
print(normality_test)

# Test d'hétéroscédasticité des résidus
arch_test <- arch.test(var_model, lags.multi = 5)
print(arch_test)

# Analyser la causalité de Granger entre les séries
# Pour chaque série, tester si elle cause les autres
for (i in colnames(ts_essence)) {
  print(causality(var_model, cause = i))
}

```

## Cointégration

```{r}
plot(log(essence_subset)-log(gaz_subset))
plot(log(essence_subset)-log(IDP_WE_subset))
plot(log(gaz_subset)-log(IDP_WE_subset))
```

```{r}
plot(ts.intersect(log(gaz_subset), log(essence_subset)), 
     plot.type = "single",            
     ylab = "Log(esssence) et Log(gaz)",
     main = "Évolution de Log(essence) et Log(gaz)")
```

```{r}
spuriousreg2 <- lm(log(gaz_subset)~log(essence_subset))
summary(spuriousreg2)
```

```{r}
library(astsa)
u2 <- residuals(spuriousreg2)
plot(ts(u2))

aux <- acf2(u2)

 aux <- acf2(diff(u2)) #Nous cherchons à connaitre le nombre de lags à intégrer  


```

```{r}
library(kableExtra)
 library(xtable)
 library(urca)
 adf.u2 <- ur.df(u2, type = "drift",
selectlags = "BIC", lags = 1)
 res.df <- data.frame(as.vector(adf.u2@teststat),
 adf.u2@cval)
 names(res.df) <- c("Stat","CV 1pct", "CV 5pct", "CV 10pct")
 xtable(res.df) %>%
 kable(digits=2) %>%
 kable_styling()
 
```

On ne peutpas rejeter l'hypothèse nulle de non-stationnarité des résidus. Par conséquent, il n'y a pas de preuve de cointégration entre les variables testées. Cela suggère qu'aucune relation d'équilibre à long terme n'existe entre ces variables sur la période étudiée.
